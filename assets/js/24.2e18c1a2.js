(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{570:function(e,t,n){"use strict";n.r(t);var a=n(18),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"拓展-vue-js-容易忽略的-api-详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#拓展-vue-js-容易忽略的-api-详解"}},[e._v("#")]),e._v(" 拓展：Vue.js 容易忽略的 API 详解")]),e._v(" "),n("p",[e._v("前面的 15 小节已经覆盖了 Vue.js 组件的绝大部分内容，但还是有一些 API 容易忽略。本节则对 Vue.js 的一些重要且易忽略的 API 进行详细介绍。")]),e._v(" "),n("h2",{attrs:{id:"nexttick"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick")]),e._v(" "),n("p",[e._v("nextTick 是 Vue.js 提供的一个函数，并非浏览器内置。nextTick 函数接收一个回调函数 "),n("code",[e._v("cb")]),e._v("，在下一个 DOM 更新循环之后执行。比如下面的示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <p v-if="show" ref="node">内容</p>\n    <button @click="handleShow">显示</button>\n  </div>\n</template>\n<script>\n  export default {\n    data () {\n      return {\n        show: false\n      }\n    },\n    methods: {\n      handleShow () {\n        this.show = true;\n        console.log(this.$refs.node);  // undefined\n        this.$nextTick(() => {\n          console.log(this.$refs.node);  // <p>内容</p>\n        });\n      }\n    }\n  }\n<\/script>\n\n')])])]),n("p",[e._v("当 "),n("code",[e._v("show")]),e._v(" 被置为 true 时，这时 p 节点还未被渲染，因此打印出的是 undefined，而在 nextTick 的回调里，p 已经渲染好了，这时能正确打印出节点。")]),e._v(" "),n("p",[e._v("nextTick 的源码在 "),n("a",{attrs:{href:"https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js"),n("OutboundLink")],1),e._v("，可以看到，Vue.js 使用了 "),n("code",[e._v("Promise")]),e._v("、"),n("code",[e._v("setTimeout")]),e._v(" 和 "),n("code",[e._v("setImmediate")]),e._v(" 三种方法来实现 nextTick，在不同环境会使用不同的方法。")]),e._v(" "),n("h2",{attrs:{id:"v-model-语法糖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v-model-语法糖"}},[e._v("#")]),e._v(" v-model 语法糖")]),e._v(" "),n("p",[n("code",[e._v("v-model")]),e._v(" 常用于表单元素上进行数据的双向绑定，比如 "),n("code",[e._v("<input>")]),e._v("。除了原生的元素，它还能在自定义组件中使用。")]),e._v(" "),n("p",[e._v("v-model 是一个语法糖，可以拆解为 props: value 和 events: input。就是说组件必须提供一个名为 value 的 prop，以及名为 input 的自定义事件，满足这两个条件，使用者就能在自定义组件上使用 "),n("code",[e._v("v-model")]),e._v("。比如下面的示例，实现了一个数字选择器：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <button @click="increase(-1)">减 1</button>\n    <span style="color: red;padding: 6px">{{ currentValue }}</span>\n    <button @click="increase(1)">加 1</button>\n  </div>\n</template>\n<script>\n  export default {\n    name: \'InputNumber\',\n    props: {\n      value: {\n        type: Number\n      }\n    },\n    data () {\n      return {\n        currentValue: this.value\n      }\n    },\n    watch: {\n      value (val) {\n        this.currentValue = val;\n      }\n    },\n    methods: {\n      increase (val) {\n        this.currentValue += val;\n        this.$emit(\'input\', this.currentValue);\n      }\n    }\n  }\n<\/script>\n\n')])])]),n("p",[e._v("props 一般不能在组件内修改，它是通过父级修改的，因此实现 v-model 一般都会有一个 "),n("code",[e._v("currentValue")]),e._v(" 的内部 data，初始时从 value 获取一次值，当 value 修改时，也通过 watch 监听到及时更新；组件不会修改 value 的值，而是修改 currentValue，同时将修改的值通过自定义事件 "),n("code",[e._v("input")]),e._v(" 派发给父组件，父组件接收到后，由父组件修改 value。所以，上面的数字选择器组件可以有下面两种使用方式：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <InputNumber v-model=\"value\" />\n</template>\n<script>\n  import InputNumber from '../components/input-number/input-number.vue';\n\n  export default {\n    components: { InputNumber },\n    data () {\n      return {\n        value: 1\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("或：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <InputNumber :value="value" @input="handleChange" />\n</template>\n<script>\n  import InputNumber from \'../components/input-number/input-number.vue\';\n\n  export default {\n    components: { InputNumber },\n    data () {\n      return {\n        value: 1\n      }\n    },\n    methods: {\n      handleChange (val) {\n        this.value = val;\n      }\n    }\n  }\n<\/script>\n\n')])])]),n("p",[e._v("如果你不想用 "),n("code",[e._v("value")]),e._v(" 和 "),n("code",[e._v("input")]),e._v(" 这两个名字，从 Vue.js 2.2.0 版本开始，提供了一个 "),n("code",[e._v("model")]),e._v(" 的选项，可以指定它们的名字，所以数字选择器组件也可以这样写：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div>\n    <button @click=\"increase(-1)\">减 1</button>\n    <span style=\"color: red;padding: 6px\">{{ currentValue }}</span>\n    <button @click=\"increase(1)\">加 1</button>\n  </div>\n</template>\n<script>\n  export default {\n    name: 'InputNumber',\n    props: {\n      number: {\n        type: Number\n      }\n    },\n    model: {\n      prop: 'number',\n      event: 'change'\n    },\n    data () {\n      return {\n        currentValue: this.number\n      }\n    },\n    watch: {\n      value (val) {\n        this.currentValue = val;\n      }\n    },\n    methods: {\n      increase (val) {\n        this.currentValue += val;\n        this.$emit('number', this.currentValue);\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("在 model 选项里，就可以指定 prop 和 event 的名字了，而不一定非要用 value 和 input，因为这两个名字在一些原生表单元素里，有其它用处。")]),e._v(" "),n("h2",{attrs:{id:"sync-修饰符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sync-修饰符"}},[e._v("#")]),e._v(" .sync 修饰符")]),e._v(" "),n("p",[e._v("如果你使用过 Vue.js 1.x，一定对 "),n("code",[e._v(".sync")]),e._v(" 不陌生。在 1.x 里，可以使用 .sync 双向绑定数据，也就是父组件或子组件都能修改这个数据，是双向响应的。在 Vue.js 2.x 里废弃了这种用法，目的是尽可能将父子组件解耦，避免子组件无意中修改了父组件的状态。")]),e._v(" "),n("p",[e._v("不过在 Vue.js 2.3.0 版本，又增加了 "),n("code",[e._v(".sync")]),e._v(" 修饰符，但它的用法与 1.x 的不完全相同。2.x 的 .sync 不是真正的双向绑定，而是一个语法糖，修改数据还是在父组件完成的，并非在子组件。")]),e._v(" "),n("p",[e._v("仍然是数字选择器的示例，这次不用 v-model，而是用 .sync，可以这样改写：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <button @click="increase(-1)">减 1</button>\n    <span style="color: red;padding: 6px">{{ value }}</span>\n    <button @click="increase(1)">加 1</button>\n  </div>\n</template>\n<script>\n  export default {\n    name: \'InputNumber\',\n    props: {\n      value: {\n        type: Number\n      }\n    },\n    methods: {\n      increase (val) {\n        this.$emit(\'update:value\', this.value + val);\n      }\n    }\n  }\n<\/script>\n\n')])])]),n("p",[e._v("用例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <InputNumber :value.sync=\"value\" />\n</template>\n<script>\n  import InputNumber from '../components/input-number/input-number.vue';\n\n  export default {\n    components: { InputNumber },\n    data () {\n      return {\n        value: 1\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("看起来要比 v-model 的实现简单多，实现的效果是一样的。v-model 在一个组件中只能有一个，但 .sync 可以设置很多个。.sync 虽好，但也有限制，比如：")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("不能")]),e._v("和表达式一起使用（如 "),n("code",[e._v("v-bind:title.sync=\"doc.title + '!'\"")]),e._v(" 是无效的）；")]),e._v(" "),n("li",[n("strong",[e._v("不能")]),e._v("用在字面量对象上（如 "),n("code",[e._v('v-bind.sync="{ title: doc.title }"')]),e._v(" 是无法正常工作的）。")])]),e._v(" "),n("h2",{attrs:{id:"set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" $set")]),e._v(" "),n("p",[e._v("在上一节已经介绍过 "),n("code",[e._v("$set")]),e._v("，有两种情况会用到它：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("由于 JavaScript 的限制，Vue 不能检测以下变动的数组：")]),e._v(" "),n("ol",[n("li",[e._v("当利用索引直接设置一个项时，例如："),n("code",[e._v("this.items[index] = value")]),e._v(";")]),e._v(" "),n("li",[e._v("当修改数组的长度时，例如："),n("code",[e._v("vm.items.length = newLength")]),e._v("。")])])]),e._v(" "),n("li",[n("p",[e._v("由于 JavaScript 的限制，"),n("strong",[e._v("Vue 不能检测对象属性的添加或删除")]),e._v("。")])])]),e._v(" "),n("p",[e._v("举例来看，就是：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 数组\nexport default {\n  data () {\n    return {\n      items: ['a', 'b', 'c']\n    }\n  },\n  methods: {\n    handler () {\n      this.items[1] = 'x';  // 不是响应性的\n    }\n  }\n}\n\n")])])]),n("p",[e._v("使用 "),n("code",[e._v("$set")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 数组\nexport default {\n  data () {\n    return {\n      items: ['a', 'b', 'c']\n    }\n  },\n  methods: {\n    handler () {\n      this.$set(this.items, 1, 'x');  // 是响应性的\n    }\n  }\n}\n\n")])])]),n("p",[e._v("以对象为例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 对象\nexport default {\n  data () {\n    return {\n      item: {\n        a: 1\n      }\n    }\n  },\n  methods: {\n    handler () {\n      this.item.b = 2;  // 不是响应性的\n    }\n  }\n}\n\n")])])]),n("p",[e._v("使用 "),n("code",[e._v("$set")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 对象\nexport default {\n  data () {\n    return {\n      item: {\n        a: 1\n      }\n    }\n  },\n  methods: {\n    handler () {\n      this.$set(this.item, 'b', 2);  // 是响应性的\n    }\n  }\n}\n\n")])])]),n("p",[e._v("另外，数组的以下方法，都是"),n("strong",[e._v("可以")]),e._v("触发视图更新的，也就是响应性的：")]),e._v(" "),n("p",[n("code",[e._v("push()")]),e._v("、"),n("code",[e._v("pop()")]),e._v("、"),n("code",[e._v("shift()")]),e._v("、"),n("code",[e._v("unshift()")]),e._v("、"),n("code",[e._v("splice()")]),e._v("、"),n("code",[e._v("sort()")]),e._v("、"),n("code",[e._v("reverse()")]),e._v("。")]),e._v(" "),n("p",[e._v("还有一种小技巧，就是先 copy 一个数组，然后通过 index 修改后，再把原数组整个替换，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("handler () {\n  const data = [...this.items];\n  data[1] = 'x';\n  this.items = data;\n}\n\n")])])]),n("h2",{attrs:{id:"计算属性的-set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#计算属性的-set"}},[e._v("#")]),e._v(" 计算属性的 set")]),e._v(" "),n("p",[e._v("计算属性（computed）很简单，而且也会大量使用，但大多数时候，我们只是用它默认的 get 方法，也就是平时的常规写法，通过 computed 获取一个依赖其它状态的数据。比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("computed: {\n  fullName () {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n")])])]),n("p",[e._v("这里的 fullName 事实上可以写为一个 Object，而非 Function，只是 Function 形式是我们默认使用它的 get 方法，当写为 Object 时，还能使用它的 set 方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("computed: {\n  fullName: {\n    get () {\n      return `${this.firstName} ${this.lastName}`;\n    },\n    set (val) {\n      const names = val.split(' ');\n      this.firstName = names[0];\n      this.lastName = names[names.length - 1];\n    }\n  }\n}\n\n")])])]),n("p",[e._v("计算属性大多时候只是读取用，使用了 set 后，就可以写入了，比如上面的示例，如果执行 "),n("code",[e._v("this.fullName = 'Aresn Liang'")]),e._v("，computed 的 set 就会调用，firstName 和 lastName 会被赋值为 Aresn 和 Liang。")]),e._v(" "),n("h2",{attrs:{id:"剩余值得注意的-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#剩余值得注意的-api"}},[e._v("#")]),e._v(" 剩余值得注意的 API")]),e._v(" "),n("p",[e._v("还有一些 API，可能不常用，也比较简单，只需知道就好，本册不详细展开介绍，可以通过指引到 Vue.js 文档查看。")]),e._v(" "),n("h3",{attrs:{id:"delimiters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#delimiters"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#delimiters",target:"_blank",rel:"noopener noreferrer"}},[e._v("delimiters"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("改变纯文本插入分隔符，Vue.js 默认的是 "),n("code",[e._v(e._s())]),e._v("，如果你使用其它一些后端模板，比如 Python 的 Tornado 框架，那 Vue.js 和 Tornado 的 "),n("code",[e._v(e._s())]),e._v(" 就冲突了，这时用它可以修改为指定的分隔符。")]),e._v(" "),n("h3",{attrs:{id:"v-once"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v-once"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#v-once",target:"_blank",rel:"noopener noreferrer"}},[e._v("v-once"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("只渲染元素和组件"),n("strong",[e._v("一次")]),e._v("。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。")]),e._v(" "),n("h3",{attrs:{id:"vm-isserver"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vm-isserver"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#vm-isServer",target:"_blank",rel:"noopener noreferrer"}},[e._v("vm.$isServer"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("当前 Vue 实例是否运行于服务器，如果你的组件要兼容 SSR，它会很有用。")]),e._v(" "),n("h3",{attrs:{id:"inheritattrs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#inheritattrs"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#inheritAttrs",target:"_blank",rel:"noopener noreferrer"}},[e._v("inheritAttrs"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("一些原生的 html 特性，比如 "),n("code",[e._v("id")]),e._v("，即使没有定义 props，也会被集成到组件根节点上，设置 inheritAttrs 为 false 可以关闭此特性。")]),e._v(" "),n("h3",{attrs:{id:"errorhandler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#errorhandler"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#errorHandler",target:"_blank",rel:"noopener noreferrer"}},[e._v("errorHandler"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("使用 "),n("code",[e._v("errorHandler")]),e._v(" 可以进行异常信息的获取。")]),e._v(" "),n("h3",{attrs:{id:"watch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#watch",target:"_blank",rel:"noopener noreferrer"}},[e._v("watch"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("监听状态的变化，用的也很多了，但它和 computed 一样，也有 Object 的写法，这样能配置更多的选项，比如：")]),e._v(" "),n("ul",[n("li",[e._v("handler 执行的函数")]),e._v(" "),n("li",[e._v("deep 是否深度")]),e._v(" "),n("li",[e._v("immediate 是否立即执行")])]),e._v(" "),n("p",[e._v("完整的配置可以阅读文档。")]),e._v(" "),n("h3",{attrs:{id:"comments"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#comments"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("comments"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("开启会保留 html 注释。")]),e._v(" "),n("h3",{attrs:{id:"transition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#transition"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#transition",target:"_blank",rel:"noopener noreferrer"}},[e._v("transition"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("内置的组件，可做过渡效果，比如 CSS 的高度从 0 到 auto（使用纯 CSS 是无法实现动画的）。")]),e._v(" "),n("h2",{attrs:{id:"结语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),n("p",[e._v("彻底掌握一门语言（框架），不需要阅读它所有的源码，但至少要阅读它所有的 "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/",target:"_blank",rel:"noopener noreferrer"}},[e._v("API"),n("OutboundLink")],1),e._v("。")])])}),[],!1,null,null,null);t.default=r.exports}}]);