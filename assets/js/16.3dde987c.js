(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{562:function(e,t,n){"use strict";n.r(t);var r=n(18),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"实战-1-具有数据校验功能的表单组件-form"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实战-1-具有数据校验功能的表单组件-form"}},[e._v("#")]),e._v(" 实战 1：具有数据校验功能的表单组件——Form")]),e._v(" "),n("p",[e._v("在第 3 节和第 4 节中，我们介绍了组件间的两种通信方法：provide / inject 和 dispatch / broadcast，前者是 Vue.js 内置的，主要用于子组件获取父组件（包括跨级）的状态；后者是自行实现的一种混合，用于父子组件（包括跨级）间通过自定义事件通信。本小节则基于这两种通信方法，来实现一个具有数据校验功能的表单组件——Form。")]),e._v(" "),n("h2",{attrs:{id:"form-组件概览"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#form-组件概览"}},[e._v("#")]),e._v(" Form 组件概览")]),e._v(" "),n("p",[e._v("表单类组件在项目中会大量使用，比如输入框（Input）、单选（Radio）、多选（Checkbox）、下拉选择器（Select）等。在使用表单类组件时，也会经常用到数据校验，如果每次都写校验程序来对每一个表单控件校验，会很低效，因此需要一个能够校验基础表单控件的组件，也就是本节要完成的 Form 组件。一般的组件库都提供了这个组件，比如 iView，它能够校验内置的 15 种控件，且支持校验自定义组件，如下图所示：")]),e._v(" "),n("p",[e._v("（也可以在线访问本示例体验："),n("a",{attrs:{href:"https://run.iviewui.com/jwrqnFss",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://run.iviewui.com/jwrqnFss"),n("OutboundLink")],1),e._v("）")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/30/166c3b75c37ef9a8?w=900&h=958&f=gif&s=1820338",alt:""}})]),e._v(" "),n("p",[e._v("Form 组件分为两个部分，一个是外层的 "),n("code",[e._v("Form")]),e._v(" 表单域组件，一组表单控件只有一个 Form，而内部包含了多个 "),n("code",[e._v("FormItem")]),e._v(" 组件，每一个表单控件都被一个 FormItem 包裹。基本的结构看起来像：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<i-form>\n  <i-form-item>\n    <i-input v-model="form.name"></i-input>\n  </i-form-item>\n  <i-form-item>\n    <i-input v-model="form.mail"></i-input>\n  </i-form-item>\n</i-form>\n\n')])])]),n("p",[e._v("Form 要用到数据校验，并在对应的 FormItem 中给出校验失败的提示，校验我们会用到一个开源库："),n("a",{attrs:{href:"https://github.com/yiminghe/async-validator",target:"_blank",rel:"noopener noreferrer"}},[e._v("async-validator"),n("OutboundLink")],1),e._v("，基本主流的组件库都是基于它做的校验。使用它很简单，只需按要求写好一个校验规则就好，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("[\n  { required: true, message: '邮箱不能为空', trigger: 'blur' },\n  { type: 'email', message: '邮箱格式不正确', trigger: 'blur' }\n]\n\n")])])]),n("p",[e._v("这个代表要校验的数据先判断是否为空（required: true），如果为空，则提示“邮箱不能为空”，触发校验的事件为失焦（trigger: 'blur'），如果第一条满足要求，再进行第二条的验证，判断是否为邮箱格式（type: 'email'）等等，还支持自定义校验规则。更详细的用法可以参看它的文档。")]),e._v(" "),n("h2",{attrs:{id:"接口设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口设计"}},[e._v("#")]),e._v(" 接口设计")]),e._v(" "),n("p",[e._v("我们先使用最新的 Vue CLI 3 创建一个空白的项目（如果你还不清楚 Vue CLI 3 的用法，需要先补习一下了，可以阅读文末的扩展阅读 1），并使用 "),n("code",[e._v("vue-router")]),e._v(" 插件，同时安装好 "),n("code",[e._v("async-validator")]),e._v(" 库。")]),e._v(" "),n("p",[e._v("在 "),n("code",[e._v("src/components")]),e._v(" 下新建一个 "),n("code",[e._v("form")]),e._v(" 文件夹，并初始化两个组件 "),n("code",[e._v("form.vue")]),e._v(" 和 "),n("code",[e._v("form-item.vue")]),e._v("，然后初始化项目，配置路由，创建一个页面能够被访问到。")]),e._v(" "),n("blockquote",[n("p",[e._v("本节所有代码可以在 "),n("a",{attrs:{href:"https://github.com/icarusion/vue-component-book",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/icarusion/vue-component-book"),n("OutboundLink")],1),e._v(" 中查看，你可以一边看源码，一边阅读本节；也可以边阅读，边动手实现一遍，遇到问题再参考完整的源码。")])]),e._v(" "),n("p",[e._v("第 2 节我们介绍到，编写一个 Vue.js 组件，最重要的是设计好它的接口，一个 Vue.js 组件的接口来自三个部分：props、slots、events。而 Form 和 FormItem 两个组件主要做数据校验，用不到 events。Form 的 slot 就是一系列的 FormItem，FormItem 的 slot 就是具体的表单控件，比如输入框 "),n("code",[e._v("<i-input>")]),e._v(" 。那主要设计的就是 props 了。")]),e._v(" "),n("p",[e._v("在 "),n("code",[e._v("Form")]),e._v(" 组件中，定义两个 props：")]),e._v(" "),n("ul",[n("li",[e._v("model：表单控件绑定的数据对象，在校验或重置时会访问该数据对象下对应的表单数据，类型为 Object。")]),e._v(" "),n("li",[e._v("rules：表单验证规则，即上面介绍的 async-validator 所使用的校验规则，类型为 Object。")])]),e._v(" "),n("p",[e._v("在 "),n("code",[e._v("FormItem")]),e._v(" 组件中，也定义两个 props：")]),e._v(" "),n("ul",[n("li",[e._v("label：单个表单组件的标签文本，类似原生的 "),n("code",[e._v("<label>")]),e._v(" 元素，类型为 String。")]),e._v(" "),n("li",[e._v("prop：对应表单域 Form 组件 model 里的字段，用于在校验或重置时访问表单组件绑定的数据，类型为 String。")])]),e._v(" "),n("p",[e._v("定义好 props，就可以写出大概的用例了：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div>\n    <i-form :model=\"formValidate\" :rules=\"ruleValidate\">\n      <i-form-item label=\"用户名\" prop=\"name\">\n        <i-input v-model=\"formValidate.name\"></i-input>\n      </i-form-item>\n      <i-form-item label=\"邮箱\" prop=\"mail\">\n        <i-input v-model=\"formValidate.mail\"></i-input>\n      </i-form-item>\n    </i-form>\n  </div>\n</template>\n<script>\n  import iForm from '../components/form/form.vue';\n  import iFormItem from '../components/form/form-item.vue';\n  import iInput from '../components/input/input.vue';\n\n  export default {\n    components: { iForm, iFormItem, iInput },\n    data () {\n      return {\n        formValidate: {\n          name: '',\n          mail: ''\n        },\n        ruleValidate: {\n          name: [\n            { required: true, message: '用户名不能为空', trigger: 'blur' }\n          ],\n          mail: [\n            { required: true, message: '邮箱不能为空', trigger: 'blur' },\n            { type: 'email', message: '邮箱格式不正确', trigger: 'blur' }\n          ],\n        }\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("有两点需要注意的是：")]),e._v(" "),n("ol",[n("li",[e._v("这里的 "),n("code",[e._v("<i-input>")]),e._v(" 并不是原生的 "),n("code",[e._v("<input>")]),e._v(" 输入框，而是一个特制的输入框组件，之后会介讲解的功能和代码；")]),e._v(" "),n("li",[n("code",[e._v("<i-form-item>")]),e._v(" 的属性 "),n("code",[e._v("prop")]),e._v(" 是字符串，所以它前面没有冒号（即不是 "),n("code",[e._v(':prop="name"')]),e._v("）。")])]),e._v(" "),n("p",[e._v("当前的两个组件只是个框框，还没有实现任何功能，不过万事开头难，定义好接口，剩下的就是补全组件的逻辑，而对于使用者，知道了 props、events、slots，就已经能写出上例的使用代码了。")]),e._v(" "),n("p",[e._v("到此，Form 和 FormItem 的代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!-- form.vue --\x3e\n<template>\n  <form>\n    <slot></slot>\n  </form>\n</template>\n<script>\n  export default {\n    name: 'iForm',\n    props: {\n      model: {\n        type: Object\n      },\n      rules: {\n        type: Object\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!-- form-item.vue --\x3e\n<template>\n  <div>\n    <label v-if=\"label\">{{ label }}</label>\n    <div>\n      <slot></slot>\n    </div>\n  </div>\n</template>\n<script>\n  export default {\n    name: 'iFormItem',\n    props: {\n      label: {\n        type: String,\n        default: ''\n      },\n      prop: {\n        type: String\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("h2",{attrs:{id:"在-form-中缓存-formitem-实例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在-form-中缓存-formitem-实例"}},[e._v("#")]),e._v(" 在 Form 中缓存 FormItem 实例")]),e._v(" "),n("p",[n("code",[e._v("Form")]),e._v(" 组件的核心功能是数据校验，一个 Form 中包含了多个 FormItem，当点击提交按钮时，要逐一对每个 FormItem 内的表单组件校验，而校验是由使用者发起，并通过 "),n("code",[e._v("Form")]),e._v(" 来调用每一个 "),n("code",[e._v("FormItem")]),e._v(" 的验证方法，再将校验结果汇总后，通过 "),n("code",[e._v("Form")]),e._v(" 返回出去。大致的流程如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/30/166c3b7f124cb84a?w=1046&h=610&f=png&s=42610",alt:""}})]),e._v(" "),n("p",[e._v("因为要在 Form 中逐一调用 FormItem 的验证方法，而 Form 和 FormItem 是独立的，需要预先将 FormItem 的每个实例缓存在 Form 中，这个操作就需要用到第 4 节的组件通信方法。当每个 FormItem 渲染时，将其自身（this）作为参数通过 "),n("code",[e._v("dispatch")]),e._v(" 派发到 Form 组件中，然后通过一个数组缓存起来；同理当 FormItem 销毁时，将其从 Form 缓存的数组中移除。相关代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form-item.vue，部分代码省略\n\nimport Emitter from '../../mixins/emitter.js';\n\nexport default {\n  name: 'iFormItem',\n  mixins: [ Emitter ],\n  // 组件渲染时，将实例缓存在 Form 中\n  mounted () {\n    // 如果没有传入 prop，则无需校验，也就无需缓存\n    if (this.prop) {\n      this.dispatch('iForm', 'on-form-item-add', this);\n    }\n  },\n  // 组件销毁前，将实例从 Form 的缓存中移除\n  beforeDestroy () {\n    this.dispatch('iForm', 'on-form-item-remove', this);\n  }\n}\n\n")])])]),n("p",[e._v("注意，Vue.js 的组件渲染顺序是由内而外的，所以 FormItem 要先于 Form 渲染，在 FormItem 的 mounted 触发时，我们向 Form 派发了事件 "),n("code",[e._v("on-form-item-add")]),e._v("，并将当前 FormItem 的实例（this）传递给了 Form，而此时，Form 的 mounted 尚未触发，因为 Form 在最外层，如果在 Form 的 mounted 里监听事件，是不可以的，所以要在其 created 内监听自定义事件，Form 的 created 要先于 FormItem 的 mounted。所以 Form 的相关代码为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form.vue，部分代码省略\nexport default {\n  name: 'iForm',\n  data () {\n    return {\n      fields: []\n    };\n  },\n  created () {\n    this.$on('on-form-item-add', (field) => {\n      if (field) this.fields.push(field);\n    });\n    this.$on('on-form-item-remove', (field) => {\n      if (field.prop) this.fields.splice(this.fields.indexOf(field), 1);\n    });\n  }\n}\n\n")])])]),n("p",[e._v("定义的数据 "),n("code",[e._v("fields")]),e._v(" 就是用来缓存所有 FormItem 实例的。")]),e._v(" "),n("h2",{attrs:{id:"触发校验"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#触发校验"}},[e._v("#")]),e._v(" 触发校验")]),e._v(" "),n("p",[e._v("Form 支持两种事件来触发校验：")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("blur")]),e._v("：失去焦点时触发，常见的有输入框失去焦点时触发校验；")]),e._v(" "),n("li",[n("strong",[e._v("change")]),e._v("：实时输入时触发或选择时触发，常见的有输入框实时输入时触发校验、下拉选择器选择项目时触发校验等。")])]),e._v(" "),n("p",[e._v("以上两个事件，都是有具体的表单组件来触发的，我们先来编写一个简单的输入框组件 "),n("code",[e._v("i-input")]),e._v("。在 "),n("code",[e._v("components")]),e._v(" 下新建目录 "),n("code",[e._v("input")]),e._v("，并创建文件 "),n("code",[e._v("input.vue")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!-- input.vue --\x3e\n<template>\n  <input\n         type=\"text\"\n         :value=\"currentValue\"\n         @input=\"handleInput\"\n         @blur=\"handleBlur\"\n         />\n</template>\n<script>\n  import Emitter from '../../mixins/emitter.js';\n\n  export default {\n    name: 'iInput',\n    mixins: [ Emitter ],\n    props: {\n      value: {\n        type: String,\n        default: ''\n      },\n    },\n    data () {\n      return {\n        currentValue: this.value\n      }\n    },\n    watch: {\n      value (val) {\n        this.currentValue = val;\n      }\n    },\n    methods: {\n      handleInput (event) {\n        const value = event.target.value;\n        this.currentValue = value;\n        this.$emit('input', value);\n        this.dispatch('iFormItem', 'on-form-change', value);\n      },\n      handleBlur () {\n        this.dispatch('iFormItem', 'on-form-blur', this.currentValue);\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("Input 组件中，绑定在 "),n("code",[e._v("<input>")]),e._v(" 元素上的原生事件 "),n("code",[e._v("@input")]),e._v("，每当输入一个字符，都会调用句柄 "),n("code",[e._v("handleInput")]),e._v("，并通过 "),n("code",[e._v("dispatch")]),e._v(" 方法向上级的 FormItem 组件派发自定义事件 "),n("code",[e._v("on-form-change")]),e._v("；同理，绑定的原生事件 "),n("code",[e._v("@blur")]),e._v(" 会在 input 失焦时触发，并传递事件 "),n("code",[e._v("on-form-blur")]),e._v("。")]),e._v(" "),n("p",[e._v("基础组件有了，接下来要做的，是在 FormItem 中监听来自 Input 组件派发的自定义事件。这里可以在 mounted 中监听，因为你的手速远赶不上组件渲染的速度，不过在 created 中监听也是没任何问题的。相关代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form-item.vue，部分代码省略\nexport default {\n  methods: {\n    setRules () {\n      this.$on('on-form-blur', this.onFieldBlur);\n      this.$on('on-form-change', this.onFieldChange);\n    },\n  },\n  mounted () {\n    if (this.prop) {\n      this.dispatch('iForm', 'on-form-item-add', this);\n      this.setRules();\n    }\n  }\n}\n\n")])])]),n("p",[e._v("通过调用 "),n("code",[e._v("setRules")]),e._v(" 方法，监听表单组件的两个事件，并绑定了句柄函数 "),n("code",[e._v("onFieldBlur")]),e._v(" 和 "),n("code",[e._v("onFieldChange")]),e._v("，分别对应 blur 和 change 两种事件类型。当 onFieldBlur 或 onFieldChange 函数触发时，就意味着 FormItem 要对"),n("strong",[e._v("当前的数据")]),e._v("进行一次校验。当前的数据，指的就是通过表单域 Form 中定义的 props：model，结合当前 FormItem 定义的 props：prop 来确定的数据，可以回顾上文写过的用例。")]),e._v(" "),n("p",[e._v("因为 FormItem 中只定义了数据源的某个 key 名称（即属性 prop），要拿到 Form 中 model 里的数据，需要用到第 3 节的通信方法 provide / inject。所以在 Form 中，把整个实例（this）向下提供，并在 FormItem 中注入：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form.vue，部分代码省略\nexport default {\n  provide() {\n    return {\n      form : this\n    };\n  }\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form-item.vue，部分代码省略\nexport default {\n  inject: ['form']\n}\n\n")])])]),n("p",[e._v("准备好这些，接着就是最核心的校验功能了。blur 和 change 事件都会触发校验，它们调用同一个方法，只是参数不同。相关代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form-item.vue，部分代码省略\nimport AsyncValidator from 'async-validator';\n\nexport default {\n  inject: ['form'],\n  props: {\n    prop: {\n      type: String\n    },\n  },\n  data () {\n    return {\n      validateState: '',  // 校验状态\n      validateMessage: '',  // 校验不通过时的提示信息\n    }\n  },\n  computed: {\n    // 从 Form 的 model 中动态得到当前表单组件的数据\n    fieldValue () {\n      return this.form.model[this.prop];\n    }\n  },\n  methods: {\n    // 从 Form 的 rules 属性中，获取当前 FormItem 的校验规则\n    getRules () {\n      let formRules = this.form.rules;\n\n      formRules = formRules ? formRules[this.prop] : [];\n\n      return [].concat(formRules || []);\n    },\n    // 只支持 blur 和 change，所以过滤出符合要求的 rule 规则\n    getFilteredRule (trigger) {\n      const rules = this.getRules();\n      return rules.filter(rule => !rule.trigger || rule.trigger.indexOf(trigger) !== -1);\n    },\n    /**\n     * 校验数据\n     * @param trigger 校验类型\n     * @param callback 回调函数\n     */\n    validate(trigger, callback = function () {}) {\n      let rules = this.getFilteredRule(trigger);\n\n      if (!rules || rules.length === 0) {\n        return true;\n      }\n\n      // 设置状态为校验中\n      this.validateState = 'validating';\n\n      // 以下为 async-validator 库的调用方法\n      let descriptor = {};\n      descriptor[this.prop] = rules;\n\n      const validator = new AsyncValidator(descriptor);\n      let model = {};\n\n      model[this.prop] = this.fieldValue;\n\n      validator.validate(model, { firstFields: true }, errors => {\n        this.validateState = !errors ? 'success' : 'error';\n        this.validateMessage = errors ? errors[0].message : '';\n\n        callback(this.validateMessage);\n      });\n    },\n    onFieldBlur() {\n      this.validate('blur');\n    },\n    onFieldChange() {\n      this.validate('change');\n    }\n  }\n}\n\n")])])]),n("p",[e._v("在 FormItem 的 "),n("code",[e._v("validate()")]),e._v(" 方法中，最终做了两件事：")]),e._v(" "),n("ol",[n("li",[e._v("设置了当前的校验状态 "),n("code",[e._v("validateState")]),e._v(" 和校验不通过提示信息 "),n("code",[e._v("validateMessage")]),e._v("（通过值为空）；")]),e._v(" "),n("li",[e._v("将 validateMessage 通过回调 callback 传递给调用者，这里的调用者是 onFieldBlur 和 onFieldChange，它们只传入了第一个参数 "),n("code",[e._v("trigger")]),e._v("，callback 并未传入，因此也不会触发回调，而这个回调主要是给 Form 用的，因为 Form 中可以通过提交按钮一次性校验所有的 FormItem（后文会介绍）这里只是表单组件触发事件时，对当前 FormItem 做校验。")])]),e._v(" "),n("p",[e._v("除了校验，还可以对当前数据进行重置。重置是指将表单组件的数据还原到最初绑定的值，而不是清空，因此需要预先缓存一份初始值。同时我们将校验信息也显示在模板中，并加一些样式。相关代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!-- form-item.vue，部分代码省略 --\x3e\n<template>\n  <div>\n    <label v-if=\"label\" :class=\"{ 'i-form-item-label-required': isRequired }\">{{ label }}</label>\n    <div>\n      <slot></slot>\n      <div v-if=\"validateState === 'error'\" class=\"i-form-item-message\">{{ validateMessage }}</div>\n    </div>\n  </div>\n</template>\n<script>\n  export default {\n    props: {\n      label: {\n        type: String,\n        default: ''\n      },\n      prop: {\n        type: String\n      },\n    },\n    data () {\n      return {\n        isRequired: false,  // 是否为必填\n        validateState: '',  // 校验状态\n        validateMessage: '',  // 校验不通过时的提示信息\n      }\n    },\n    mounted () {\n      // 如果没有传入 prop，则无需校验，也就无需缓存\n      if (this.prop) {\n        this.dispatch('iForm', 'on-form-item-add', this);\n\n        // 设置初始值，以便在重置时恢复默认值\n        this.initialValue = this.fieldValue;\n\n        this.setRules();\n      }\n    },\n    methods: {\n      setRules () {\n        let rules = this.getRules();\n        if (rules.length) {\n          rules.every((rule) => {\n            // 如果当前校验规则中有必填项，则标记出来\n            this.isRequired = rule.required;\n          });\n        }\n\n        this.$on('on-form-blur', this.onFieldBlur);\n        this.$on('on-form-change', this.onFieldChange);\n      },\n      // 从 Form 的 rules 属性中，获取当前 FormItem 的校验规则\n      getRules () {\n        let formRules = this.form.rules;\n\n        formRules = formRules ? formRules[this.prop] : [];\n\n        return [].concat(formRules || []);\n      },\n      // 重置数据\n      resetField () {\n        this.validateState = '';\n        this.validateMessage = '';\n\n        this.form.model[this.prop] = this.initialValue;\n      },\n    }\n  }\n<\/script>\n<style>\n  .i-form-item-label-required:before {\n    content: '*';\n    color: red;\n  }\n  .i-form-item-message {\n    color: red;\n  }\n</style>\n\n")])])]),n("p",[e._v("至此，FormItem 代码已经完成，不过它只具有单独校验的功能，也就是说，只能对自己的一个表单组件验证，不能对一个表单域里的所有组件一次性全部校验。而实现全部校验和全部重置的功能，要在 Form 中完成。")]),e._v(" "),n("p",[e._v("上文已经介绍到，在 "),n("code",[e._v("Form")]),e._v(" 组件中，预先缓存了全部的 FormItem 实例，自然也能在 Form 中调用它们。通过点击提交按钮全部校验，或点击重置按钮全部重置数据，只需要在 Form 中，逐一调用缓存的 FormItem 实例中的 "),n("code",[e._v("validate")]),e._v(" 或 "),n("code",[e._v("resetField")]),e._v(" 方法。相关代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// form.vue，部分代码省略\nexport default {\n  data () {\n    return {\n      fields: []\n    };\n  },\n  methods: {\n    // 公开方法：全部重置数据\n    resetFields() {\n      this.fields.forEach(field => {\n        field.resetField();\n      });\n    },\n    // 公开方法：全部校验数据，支持 Promise\n    validate(callback) {\n      return new Promise(resolve => {\n        let valid = true;\n        let count = 0;\n        this.fields.forEach(field => {\n          field.validate('', errors => {\n            if (errors) {\n              valid = false;\n            }\n            if (++count === this.fields.length) {\n              // 全部完成\n              resolve(valid);\n              if (typeof callback === 'function') {\n                callback(valid);\n              }\n            }\n          });\n        });\n      });\n    }\n  },\n}\n\n")])])]),n("p",[e._v("虽然说 Vue.js 的 API 只来自 prop、event、slot 这三个部分，但一些场景下，需要通过 "),n("code",[e._v("ref")]),e._v(" 来访问这个组件，调用它的一些内置方法，比如上面的 "),n("code",[e._v("validate")]),e._v(" 和 "),n("code",[e._v("resetFields")]),e._v(" 方法，就需要使用者来主动调用。")]),e._v(" "),n("p",[e._v("resetFields 很简单，就是通过循环逐一调用 FormItem 的 resetField 方法来重置数据。validate 稍显复杂，它支持两种使用方法，一种是普通的回调，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div>\n    <i-form ref=\"form\"></i-form>\n    <button @click=\"handleSubmit\">提交</button>\n  </div>\n</template>\n<script>\n  export default {\n    methods: {\n      handleSubmit () {\n        this.$refs.form.validate((valid) => {\n          if (valid) {\n            window.alert('提交成功');\n          } else {\n            window.alert('表单校验失败');\n          }\n        })\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("同时也支持 Promise，例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("handleSubmit () {\n  const validate = this.$refs.form.validate();\n  \n  validate.then((valid) => {\n    if (valid) {\n      window.alert('提交成功');\n    } else {\n      window.alert('表单校验失败');\n    }\n  })\n}\n\n")])])]),n("p",[e._v("在 Form 组件定义的 Promise 中，只调用了 resolve(valid)，没有调用 reject()，因此不能直接使用 "),n("code",[e._v(".catch()")]),e._v(" ，不过聪明的你稍作修改，肯定能够支持到！")]),e._v(" "),n("p",[e._v("完整的用例如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div>\n    <h3>具有数据校验功能的表单组件——Form</h3>\n    <i-form ref=\"form\" :model=\"formValidate\" :rules=\"ruleValidate\">\n      <i-form-item label=\"用户名\" prop=\"name\">\n        <i-input v-model=\"formValidate.name\"></i-input>\n      </i-form-item>\n      <i-form-item label=\"邮箱\" prop=\"mail\">\n        <i-input v-model=\"formValidate.mail\"></i-input>\n      </i-form-item>\n    </i-form>\n    <button @click=\"handleSubmit\">提交</button>\n    <button @click=\"handleReset\">重置</button>\n  </div>\n</template>\n<script>\n  import iForm from '../components/form/form.vue';\n  import iFormItem from '../components/form/form-item.vue';\n  import iInput from '../components/input/input.vue';\n\n  export default {\n    components: { iForm, iFormItem, iInput },\n    data () {\n      return {\n        formValidate: {\n          name: '',\n          mail: ''\n        },\n        ruleValidate: {\n          name: [\n            { required: true, message: '用户名不能为空', trigger: 'blur' }\n          ],\n          mail: [\n            { required: true, message: '邮箱不能为空', trigger: 'blur' },\n            { type: 'email', message: '邮箱格式不正确', trigger: 'blur' }\n          ],\n        }\n      }\n    },\n    methods: {\n      handleSubmit () {\n        this.$refs.form.validate((valid) => {\n          if (valid) {\n            window.alert('提交成功');\n          } else {\n            window.alert('表单校验失败');\n          }\n        })\n      },\n      handleReset () {\n        this.$refs.form.resetFields();\n      }\n    }\n  }\n<\/script>\n\n")])])]),n("p",[e._v("运行效果：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/30/166c3b8a77e382ec?w=1417&h=550&f=png&s=60805",alt:""}})]),e._v(" "),n("p",[e._v("完整的示例源码可通过 GitHub 查看：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/icarusion/vue-component-book",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/icarusion/vue-component-book"),n("OutboundLink")],1)]),e._v(" "),n("blockquote",[n("p",[e._v("项目基于 Vue CLI 3 构建，下载安装依赖后，通过 npm run serve 可访问。")])]),e._v(" "),n("h2",{attrs:{id:"结语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),n("p",[e._v("组件最终的效果看起来有点 “low”，但它实现的功能却不简单。通过这个实战，你或许已经感受到本小册一开始说的，组件写到最后，都是在拼 JavaScript 功底。的确，Vue.js 组件为我们提供了一种新的代码组织形式，但归根到底，是离不开 JS 的。")]),e._v(" "),n("p",[e._v("这个实战，你应该对独立组件间的通信用法有进一步的认知了吧，不过，这还不是组件通信的终极方案，下一节，我们就来看看适用于任何场景的组件通信方案。")]),e._v(" "),n("p",[e._v("注：本节部分代码参考 "),n("a",{attrs:{href:"https://github.com/iview/iview/tree/2.0/src/components/form",target:"_blank",rel:"noopener noreferrer"}},[e._v("iView"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("h2",{attrs:{id:"扩展阅读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展阅读"}},[e._v("#")]),e._v(" 扩展阅读")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://juejin.im/post/5bdec6e8e51d4505327a8952",target:"_blank",rel:"noopener noreferrer"}},[e._v("一份超级详细的Vue-cli3.0使用教程"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);