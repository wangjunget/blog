(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{428:function(n,e,t){"use strict";t.r(e);var o=t(0),a=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"组件的通信-3：找到任意组件实例——findcomponents-系列方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件的通信-3：找到任意组件实例——findcomponents-系列方法","aria-hidden":"true"}},[n._v("#")]),n._v(" 组件的通信 3：找到任意组件实例——findComponents 系列方法")]),n._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[n._v("#")]),n._v(" 概述")]),n._v(" "),t("p",[n._v("前面的小节我们已经介绍了两种组件间通信的方法：provide / inject 和 dispatch / broadcast。它们有各自的使用场景和局限，比如前者多用于子组件获取父组件的状态，后者常用于父子组件间通过自定义事件通信。")]),n._v(" "),t("p",[n._v("本节将介绍第 3 种组件通信方法，也就是 findComponents 系列方法，它并非 Vue.js 内置，而是需要自行实现，以工具函数的形式来使用，它是一系列的函数，可以说是组件通信的终极方案。findComponents 系列方法最终都是返回组件的实例，进而可以读取或调用该组件的数据和方法。")]),n._v(" "),t("p",[n._v("它适用于以下场景：")]),n._v(" "),t("ul",[t("li",[n._v("由一个组件，向上找到最近的指定组件；")]),n._v(" "),t("li",[n._v("由一个组件，向上找到所有的指定组件；")]),n._v(" "),t("li",[n._v("由一个组件，向下找到最近的指定组件；")]),n._v(" "),t("li",[n._v("由一个组件，向下找到所有指定的组件；")]),n._v(" "),t("li",[n._v("由一个组件，找到指定组件的兄弟组件。")])]),n._v(" "),t("p",[n._v("5 个不同的场景，对应 5 个不同的函数，实现原理也大同小异。")]),n._v(" "),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[n._v("#")]),n._v(" 实现")]),n._v(" "),t("p",[n._v("5 个函数的原理，都是通过递归、遍历，找到指定组件的 "),t("code",[n._v("name")]),n._v(" 选项匹配的组件实例并返回。")]),n._v(" "),t("blockquote",[t("p",[n._v("本节以及后续章节，都是基于上一节的工程来完成，后续不再重复说明。")]),n._v(" "),t("p",[n._v("完整源码地址："),t("a",{attrs:{href:"https://github.com/icarusion/vue-component-book",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://github.com/icarusion/vue-component-book"),t("OutboundLink")],1)])]),n._v(" "),t("p",[n._v("在目录 "),t("code",[n._v("src")]),n._v(" 下新建文件夹 "),t("code",[n._v("utils")]),n._v(" 用来放置工具函数，并新建文件 "),t("code",[n._v("assist.js")]),n._v("，本节所有函数都在这个文件里完成，每个函数都通过 "),t("code",[n._v("export")]),n._v(" 对外提供（如果你不了解 export，请查看扩展阅读1）。")]),n._v(" "),t("h3",{attrs:{id:"向上找到最近的指定组件——findcomponentupward"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#向上找到最近的指定组件——findcomponentupward","aria-hidden":"true"}},[n._v("#")]),n._v(" 向上找到最近的指定组件——findComponentUpward")]),n._v(" "),t("p",[n._v("先看代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// assist.js\n// 由一个组件，向上找到最近的指定组件\nfunction findComponentUpward (context, componentName) {\n  let parent = context.$parent;\n  let name = parent.$options.name;\n\n  while (parent && (!name || [componentName].indexOf(name) < 0)) {\n    parent = parent.$parent;\n    if (parent) name = parent.$options.name;\n  }\n  return parent;\n}\nexport { findComponentUpward };\n\n")])])]),t("p",[n._v("findComponentUpward 接收两个参数，第一个是当前上下文，比如你要基于哪个组件来向上寻找，一般都是基于当前的组件，也就是传入 "),t("code",[n._v("this")]),n._v("；第二个参数是要找的组件的 "),t("code",[n._v("name")]),n._v(" 。")]),n._v(" "),t("p",[n._v("findComponentUpward 方法会在 while 语句里不断向上覆盖当前的 "),t("code",[n._v("parent")]),n._v(" 对象，通过判断组件（即 parent）的 name 与传入的 componentName 是否一致，直到直到最近的一个组件为止。")]),n._v(" "),t("p",[n._v("与 dispatch 不同的是，findComponentUpward 是直接拿到组件的实例，而非通过事件通知组件。比如下面的示例，有组件 A 和组件 B，A 是 B 的父组件，在 B 中获取和调用 A 中的数据和方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-a.vue --\x3e\n<template>\n  <div>\n    组件 A\n    <component-b></component-b>\n  </div>\n</template>\n<script>\n  import componentB from './component-b.vue';\n\n  export default {\n    name: 'componentA',\n    components: { componentB },\n    data () {\n      return {\n        name: 'Aresn'\n      }\n    },\n    methods: {\n      sayHello () {\n        console.log('Hello, Vue.js');\n      }\n    }\n  }\n<\/script>\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-b.vue --\x3e\n<template>\n  <div>\n    组件 B\n  </div>\n</template>\n<script>\n  import { findComponentUpward } from '../utils/assist.js';\n\n  export default {\n    name: 'componentB',\n    mounted () {\n      const comA = findComponentUpward(this, 'componentA');\n      \n      if (comA) {\n        console.log(comA.name);  // Aresn\n        comA.sayHello();  // Hello, Vue.js\n      }\n    }\n  }\n<\/script>\n\n")])])]),t("p",[n._v("使用起来很简单，只要在需要的地方调用 findComponentUpward 方法就行，第一个参数一般都是传入 this，即当前组件的上下文（实例）。")]),n._v(" "),t("p",[n._v("上例的 comA，保险起见，加了一层 "),t("code",[n._v("if (comA)")]),n._v(" 来判断是否找到了组件 A，如果没有指定的组件而调用的话，是会报错的。")]),n._v(" "),t("p",[n._v("findComponentUpward 只会找到最近的一个组件实例，如果要找到全部符合要求的组件，就需要用到下面的这个方法。")]),n._v(" "),t("h3",{attrs:{id:"向上找到所有的指定组件——findcomponentsupward"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#向上找到所有的指定组件——findcomponentsupward","aria-hidden":"true"}},[n._v("#")]),n._v(" 向上找到所有的指定组件——findComponentsUpward")]),n._v(" "),t("p",[n._v("代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// assist.js\n// 由一个组件，向上找到所有的指定组件\nfunction findComponentsUpward (context, componentName) {\n  let parents = [];\n  const parent = context.$parent;\n\n  if (parent) {\n    if (parent.$options.name === componentName) parents.push(parent);\n    return parents.concat(findComponentsUpward(parent, componentName));\n  } else {\n    return [];\n  }\n}\nexport { findComponentsUpward };\n\n")])])]),t("p",[n._v("与 findComponentUpward 不同的是，findComponentsUpward 返回的是一个数组，包含了所有找到的组件实例（注意函数名称中多了一个“s”）。")]),n._v(" "),t("p",[n._v("findComponentsUpward 的使用场景较少，一般只用在递归组件里面（后面小节会介绍），因为这个函数是一直向上寻找父级（parent）的，只有递归组件的父级才是自身。事实上，iView 在使用这个方法也都是用在递归组件的场景，比如菜单组件 Menu。由于递归组件在 Vue.js 组件里面并不常用，那自然 findComponentsUpward 也不常用了。")]),n._v(" "),t("h3",{attrs:{id:"向下找到最近的指定组件——findcomponentdownward"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#向下找到最近的指定组件——findcomponentdownward","aria-hidden":"true"}},[n._v("#")]),n._v(" 向下找到最近的指定组件——findComponentDownward")]),n._v(" "),t("p",[n._v("代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// assist.js\n// 由一个组件，向下找到最近的指定组件\nfunction findComponentDownward (context, componentName) {\n  const childrens = context.$children;\n  let children = null;\n\n  if (childrens.length) {\n    for (const child of childrens) {\n      const name = child.$options.name;\n\n      if (name === componentName) {\n        children = child;\n        break;\n      } else {\n        children = findComponentDownward(child, componentName);\n        if (children) break;\n      }\n    }\n  }\n  return children;\n}\nexport { findComponentDownward };\n\n")])])]),t("p",[t("code",[n._v("context.$children")]),n._v(" 得到的是当前组件的全部子组件，所以需要遍历一遍，找到有没有匹配到的组件 "),t("code",[n._v("name")]),n._v("，如果没找到，继续递归找每个 $children 的 $children，直到找到最近的一个为止。")]),n._v(" "),t("p",[n._v("来看个示例，仍然是 A、B 两个组件，A 是 B 的父组件，在 A 中找到 B：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-b.vue --\x3e\n<template>\n  <div>\n    组件 B\n  </div>\n</template>\n<script>\n  export default {\n    name: 'componentB',\n    data () {\n      return {\n        name: 'Aresn'\n      }\n    },\n    methods: {\n      sayHello () {\n        console.log('Hello, Vue.js');\n      }\n    }\n  }\n<\/script>\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-a.vue --\x3e\n<template>\n  <div>\n    组件 A\n    <component-b></component-b>\n  </div>\n</template>\n<script>\n  import componentB from './component-b.vue';\n  import { findComponentDownward } from '../utils/assist.js';\n\n  export default {\n    name: 'componentA',\n    components: { componentB },\n    mounted () {\n      const comB = findComponentDownward(this, 'componentB');\n      if (comB) {\n        console.log(comB.name);  // Aresn\n        comB.sayHello();  // Hello, Vue.js\n      }\n    }\n  }\n<\/script>\n\n")])])]),t("p",[n._v("示例中的 A 和 B 是父子关系，因此也可以直接用 "),t("code",[n._v("ref")]),n._v(" 来访问，但如果不是父子关系，中间间隔多代，用它就很方便了。")]),n._v(" "),t("h3",{attrs:{id:"向下找到所有指定的组件——findcomponentsdownward"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#向下找到所有指定的组件——findcomponentsdownward","aria-hidden":"true"}},[n._v("#")]),n._v(" 向下找到所有指定的组件——findComponentsDownward")]),n._v(" "),t("p",[n._v("如果要向下找到所有的指定组件，要用到 findComponentsDownward 函数，代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// assist.js\n// 由一个组件，向下找到所有指定的组件\nfunction findComponentsDownward (context, componentName) {\n  return context.$children.reduce((components, child) => {\n    if (child.$options.name === componentName) components.push(child);\n    const foundChilds = findComponentsDownward(child, componentName);\n    return components.concat(foundChilds);\n  }, []);\n}\nexport { findComponentsDownward };\n\n")])])]),t("p",[n._v("这个函数实现的方式有很多，这里巧妙使用 "),t("code",[n._v("reduce")]),n._v(" 做累加器，并用递归将找到的组件合并为一个数组并返回，代码量较少，但理解起来稍困难。")]),n._v(" "),t("p",[n._v("用法与 findComponentDownward 大同小异，就不再写用例了。")]),n._v(" "),t("h3",{attrs:{id:"找到指定组件的兄弟组件——findbrotherscomponents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#找到指定组件的兄弟组件——findbrotherscomponents","aria-hidden":"true"}},[n._v("#")]),n._v(" 找到指定组件的兄弟组件——findBrothersComponents")]),n._v(" "),t("p",[n._v("代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// assist.js\n// 由一个组件，找到指定组件的兄弟组件\nfunction findBrothersComponents (context, componentName, exceptMe = true) {\n  let res = context.$parent.$children.filter(item => {\n    return item.$options.name === componentName;\n  });\n  let index = res.findIndex(item => item._uid === context._uid);\n  if (exceptMe) res.splice(index, 1);\n  return res;\n}\nexport { findBrothersComponents };\n\n")])])]),t("p",[n._v("相比其它 4 个函数，findBrothersComponents 多了一个参数 "),t("code",[n._v("exceptMe")]),n._v("，是否把本身除外，默认是 true。寻找兄弟组件的方法，是先获取 "),t("code",[n._v("context.$parent.$children")]),n._v("，也就是父组件的全部子组件，这里面当前包含了本身，所有也会有第三个参数 exceptMe。Vue.js 在渲染组件时，都会给每个组件加一个内置的属性 "),t("code",[n._v("_uid")]),n._v("，这个 _uid 是不会重复的，借此我们可以从一系列兄弟组件中把自己排除掉。")]),n._v(" "),t("p",[n._v("举个例子，组件 A 是组件 B 的父级，在 B 中找到所有在 A 中的兄弟组件（也就是所有在 A 中的 B 组件）：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-a.vue --\x3e\n<template>\n  <div>\n    组件 A\n    <component-b></component-b>\n  </div>\n</template>\n<script>\n  import componentB from './component-b.vue';\n  \n  export default {\n    name: 'componentA',\n    components: { componentB }\n  }\n<\/script>\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-b.vue --\x3e\n<template>\n  <div>\n    组件 B\n  </div>\n</template>\n<script>\n  import { findBrothersComponents } from '../utils/assist.js';\n  \n  export default {\n    name: 'componentB',\n    mounted () {\n      const comsB = findBrothersComponents(this, 'componentB');\n      console.log(comsB);  // ① []，空数组\n    }\n  }\n<\/script>\n\n")])])]),t("p",[n._v("在 ① 的位置，打印出的内容为空数组，原因是当前 A 中只有一个 B，而 findBrothersComponents 的第三个参数默认是 true，也就是将自己除外。如果在 A 中再写一个 B：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\x3c!-- component-a.vue --\x3e\n<template>\n  <div>\n    组件 A\n    <component-b></component-b>\n    <component-b></component-b>\n  </div>\n</template>\n\n")])])]),t("p",[n._v("这时就会打印出 "),t("code",[n._v("[VueComponent]")]),n._v("，有一个组件了，但要注意在控制台会打印两遍，因为在 A 中写了两个 B，而 "),t("code",[n._v("console.log")]),n._v(" 是在 B 中定义的，所以两个都会执行到。如果你看懂了这里，那应该明白打印的两遍 "),t("code",[n._v("[VueComponent]")]),n._v("，分别是另一个 "),t("code",[n._v("<component-b>")]),n._v("（如果没有搞懂，要仔细琢磨琢磨哦）。")]),n._v(" "),t("p",[n._v("如果将 B 中 findBrothersComponents 的第三个参数设置为 false：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// component-b.vue\nexport default {\n  name: 'componentB',\n  mounted () {\n    const comsB = findBrothersComponents(this, 'componentB', false);\n    console.log(comsB);\n  }\n}\n\n")])])]),t("p",[n._v("此时就会打印出 "),t("code",[n._v("[VueComponent, VueComponent]")]),n._v("，也就是包含自身了。")]),n._v(" "),t("p",[n._v("以上就是 5 个函数的详细介绍，get 到这 5 个，以后就再也不用担心组件通信了。")]),n._v(" "),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[n._v("#")]),n._v(" 结语")]),n._v(" "),t("p",[n._v("只有你认真开发过 Vue.js 独立组件，才会明白这 5 个函数的强大之处。")]),n._v(" "),t("h2",{attrs:{id:"扩展阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展阅读","aria-hidden":"true"}},[n._v("#")]),n._v(" 扩展阅读")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"}},[n._v("ES6 Module 的语法"),t("OutboundLink")],1)])]),n._v(" "),t("p",[n._v("注：本节部分代码参考 "),t("a",{attrs:{href:"https://github.com/iview/iview/blob/2.0/src/utils/assist.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("iView"),t("OutboundLink")],1),n._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);