(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{411:function(e,n,t){"use strict";t.r(n);var o=t(0),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实战-2：组合多选框组件——checkboxgroup-checkbox"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战-2：组合多选框组件——checkboxgroup-checkbox","aria-hidden":"true"}},[e._v("#")]),e._v(" 实战 2：组合多选框组件——CheckboxGroup & Checkbox")]),e._v(" "),t("p",[e._v("在第 5 节，我们完成了具有数据校验功能的组件 Form，本小节继续开发一个新的组件——组合多选框 Checkbox。它作为基础组件，也能集成在 Form 内并应用其验证规则。")]),e._v(" "),t("h2",{attrs:{id:"checkbox-组件概览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#checkbox-组件概览","aria-hidden":"true"}},[e._v("#")]),e._v(" Checkbox 组件概览")]),e._v(" "),t("p",[e._v("多选框组件也是由两个组件组成：CheckboxGroup 和 Checkbox。单独使用时，只需要一个 Checkbox，组合使用时，两者都要用到。效果如下图所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/2/166d39853b7facd8?w=562&h=334&f=png&s=29035",alt:""}})]),e._v(" "),t("p",[e._v("单独使用，常见的场景有注册时勾选以同意注册条款，它只有一个独立的 Checkbox 组件，并且绑定一个布尔值，示例如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<template>\n  <i-checkbox v-model="single">单独选项</i-checkbox>\n</template>\n<script>\n  export default {\n    data () {\n      return {\n        single: false\n      }\n    }\n  }\n<\/script>\n\n')])])]),t("p",[e._v("而组合使用的场景就很多了，填写表单时会经常用到，它的结构如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<template>\n  <i-checkbox-group v-model="multiple">\n    <i-checkbox label="option1">选项 1</i-checkbox>\n    <i-checkbox label="option2">选项 2</i-checkbox>\n    <i-checkbox label="option3">选项 3</i-checkbox>\n    <i-checkbox label="option4">选项 4</i-checkbox>\n  </i-checkbox-group>\n</template>\n<script>\n  export default {\n    data () {\n      return {\n        multiple: [\'option1\', \'option3\']\n      }\n    }\n  }\n<\/script>\n\n')])])]),t("p",[t("code",[e._v("v-model")]),e._v(" 用在了 CheckboxGroup 上，绑定的值为一个数组，数组的值就是内部 Checkbox 绑定的 label。")]),e._v(" "),t("p",[e._v("用法看起来比 Form 要简单多，不过也有两个个技术难点：")]),e._v(" "),t("ul",[t("li",[e._v("Checkbox 要同时支持单独使用和组合使用的场景；")]),e._v(" "),t("li",[e._v("CheckboxGroup 和 Checkbox 内可能嵌套其它的布局组件。")])]),e._v(" "),t("p",[e._v("对于第一点，要在 Checkbox 初始化时判断是否父级有 CheckboxGroup，如果有就是组合使用的，否则就是单独使用。而第二点，正好可以用上一节的通信方法，很容易就能解决。")]),e._v(" "),t("p",[e._v("两个组件并行开发，会容易理不清逻辑，不妨我们先开发独立的 Checkbox 组件。")]),e._v(" "),t("h2",{attrs:{id:"单独使用的-checkbox"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单独使用的-checkbox","aria-hidden":"true"}},[e._v("#")]),e._v(" 单独使用的 Checkbox")]),e._v(" "),t("p",[e._v("设计一个组件时，还是要从它的 3 个 API 入手：prop、event、slot。")]),e._v(" "),t("p",[e._v("因为要在 Checkbox 组件上直接使用 "),t("code",[e._v("v-model")]),e._v(" 来双向绑定数据，那必不可少的一个 prop 就是 "),t("code",[e._v("value")]),e._v("，还有 event "),t("code",[e._v("input")]),e._v("，因为 v-model 本质上是一个语法糖（如果你还不清楚这种用法，可以阅读最后的扩展阅读 1）。")]),e._v(" "),t("p",[e._v("理论上，我们只需要给 "),t("code",[e._v("value")]),e._v(" 设置为布尔值即可，也就是 true / false，不过为了扩展性，我们再定义两个 props："),t("code",[e._v("trueValue")]),e._v(" 和 "),t("code",[e._v("falseValue")]),e._v("，它们允许用户指定 "),t("code",[e._v("value")]),e._v(" 用什么值来判断是否选中。因为实际开发中，数据库中并不直接保存 true / false，而是 1 / 0 或其它字符串，如果强制使用 Boolean，使用者就要再额外转换一次，这样的 API 设计不太友好。")]),e._v(" "),t("p",[e._v("除此之外，还需要一个 "),t("code",[e._v("disabled")]),e._v(" 属性来表示是否禁用。")]),e._v(" "),t("p",[e._v("自定义事件 events 上文已经说了一个 "),t("code",[e._v("input")]),e._v("，用于实现 v-model 语法糖；另一个就是 "),t("code",[e._v("on-change")]),e._v("，当选中 / 取消选中时触发，用于通知父级状态发生了变化。")]),e._v(" "),t("p",[e._v("slot 使用默认的就好，显示辅助文本。")]),e._v(" "),t("p",[e._v("理清楚了 API，先来写一个基础的 "),t("code",[e._v("v-model")]),e._v(" 功能，这在大部分组件中都类似。")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("src/components")]),e._v(" 下新建目录 "),t("code",[e._v("checkbox")]),e._v("，并新建两个文件 "),t("code",[e._v("checkbox.vue")]),e._v(" 和 "),t("code",[e._v("checkbox-group.vue")]),e._v("。我们先来看 Checkbox：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- checkbox.vue --\x3e\n<template>\n  <label>\n    <span>\n      <input\n             type="checkbox"\n             :disabled="disabled"\n             :checked="currentValue"\n             @change="change">\n    </span>\n    <slot></slot>\n  </label>\n</template>\n<script>\n  export default {\n    name: \'iCheckbox\',\n    props: {\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      value: {\n        type: [String, Number, Boolean],\n        default: false\n      },\n      trueValue: {\n        type: [String, Number, Boolean],\n        default: true\n      },\n      falseValue: {\n        type: [String, Number, Boolean],\n        default: false\n      }\n    },\n    data () {\n      return {\n        currentValue: this.value\n      };\n    },\n    methods: {\n      change (event) {\n        if (this.disabled) {\n          return false;\n        }\n\n        const checked = event.target.checked;\n        this.currentValue = checked;\n\n        const value = checked ? this.trueValue : this.falseValue;\n        this.$emit(\'input\', value);\n        this.$emit(\'on-change\', value);\n      }\n    }\n  }\n<\/script>\n\n')])])]),t("p",[e._v("因为 "),t("code",[e._v("value")]),e._v(" 被定义为 prop，它只能由父级修改，本身是不能修改的，在 "),t("code",[e._v("<input>")]),e._v(" 触发 change 事件，也就是点击选择时，不能由 Checkbox 来修改这个 value，所以我们在 data 里定义了一个 "),t("code",[e._v("currentValue")]),e._v("，并把它绑定在 "),t("code",[e._v('<input :checked="currentValue">')]),e._v("，这样就可以在 Checkbox 内修改 "),t("code",[e._v("currentValue")]),e._v("。这是自定义组件使用 "),t("code",[e._v("v-model")]),e._v(" 的“惯用伎俩”。")]),e._v(" "),t("p",[e._v("代码看起来都很简单，但有三个细节需要额外说明：")]),e._v(" "),t("ol",[t("li",[e._v("选中的控件，直接使用了 "),t("code",[e._v('<input type="checkbox">')]),e._v("，而没有用 div + css 来自己实现选择的逻辑和样式，这样的好处是，使用 input 元素，你的自定义组件仍然为 html 内置的基础组件，可以使用浏览器默认的行为和快捷键，也就是说，浏览器知道这是一个选择框，而换成 div + css，浏览器可不知道这是个什么鬼。如果你觉得原生的 input 丑，没关系，是可以用 css 美化的，不过这不是本小册的重点，在此就不介绍了。")]),e._v(" "),t("li",[t("code",[e._v("<input>")]),e._v("、"),t("code",[e._v("<slot>")]),e._v(" 都是包裹在一个 "),t("code",[e._v("<label>")]),e._v(" 元素内的，这样做的好处是，当点击 "),t("code",[e._v("<slot>")]),e._v(" 里的文字时，"),t("code",[e._v("<input>")]),e._v(" 选框也会被触发，否则只有点击那个小框才会触发，那样不太容易选中，影响用户体验。")]),e._v(" "),t("li",[t("code",[e._v("currentValue")]),e._v(" 仍然是布尔值（true / false），因为它是组件 Checkbox 自己使用的，对于使用者无需关心，而 value 可以是 String、Number 或 Boolean，这取决于 "),t("code",[e._v("trueValue")]),e._v(" 和 "),t("code",[e._v("falseValue")]),e._v(" 的定义。")])]),e._v(" "),t("p",[e._v("现在实现的 "),t("code",[e._v("v-model")]),e._v("，只是由内而外的，也就是说，通过点击 "),t("code",[e._v("<input>")]),e._v("选择，会通知到使用者，而使用者手动修改了 prop "),t("code",[e._v("value")]),e._v(" ，Checkbox 是没有做响应的，那继续补充代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\x3c!-- checkbox.vue，部分代码省略 --\x3e\n<script>\n  export default {\n    watch: {\n      value (val) {\n        if (val === this.trueValue || val === this.falseValue) {\n          this.updateModel();\n        } else {\n          throw 'Value should be trueValue or falseValue.';\n        }\n      }\n    },\n    methods: {\n      updateModel () {\n        this.currentValue = this.value === this.trueValue;\n      }\n    }\n  }\n<\/script>\n\n")])])]),t("p",[e._v("我们对 prop "),t("code",[e._v("value")]),e._v(" 使用 watch 进行了监听，当父级修改它时，会调用 "),t("code",[e._v("updateModel")]),e._v(" 方法，同步修改内部的 "),t("code",[e._v("currentValue")]),e._v(" 。不过，不是所有的值父级都能修改的，所以用 if 条件判断了父级修改的值是否符合 trueValue / falseValue 所设置的，否则会抛错。")]),e._v(" "),t("p",[e._v("Checkbox 也是一个基础的表单类组件，它完全可以集成到 Form 里，所以，我们使用 Emitter 在 change 事件触发时，向 Form 派发一个事件，这样你就可以用第 5 节的 Form 组件来做数据校验了：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\x3c!-- checkbox.vue，部分代码省略 --\x3e\n<script>\n  import Emitter from '../../mixins/emitter.js';\n\n  export default {\n    mixins: [ Emitter ],\n    methods: {\n      change (event) {\n        // ... \n        this.$emit('input', value);\n        this.$emit('on-change', value);\n        this.dispatch('iFormItem', 'on-form-change', value);\n      }\n    },\n  }\n<\/script>\n\n")])])]),t("p",[e._v("至此，Checkbox 已经可以单独使用了，并支持 Form 的数据校验。下面来看组合使用。")]),e._v(" "),t("h3",{attrs:{id:"组合使用的-checkboxgroup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合使用的-checkboxgroup","aria-hidden":"true"}},[e._v("#")]),e._v(" 组合使用的 CheckboxGroup")]),e._v(" "),t("blockquote",[t("p",[e._v("友情提示：请先阅读 Vue.js 文档的 "),t("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/forms.html#%E5%A4%8D%E9%80%89%E6%A1%86",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cn.vuejs.org/v2/guide/forms.html#复选框"),t("OutboundLink")],1),e._v(" 内容。")])]),e._v(" "),t("p",[e._v("CheckboxGroup 的 API 很简单：")]),e._v(" "),t("ul",[t("li",[e._v("props："),t("code",[e._v("value")]),e._v("，与 Checkbox 的类似，用于 v-model 双向绑定数据，格式为数组；")]),e._v(" "),t("li",[e._v("events："),t("code",[e._v("on-change")]),e._v("，同 Checkbox；")]),e._v(" "),t("li",[e._v("slots：默认，用于放置 Checkbox。")])]),e._v(" "),t("p",[e._v("如果写了 CheckboxGroup，那就代表你要组合使用多选框，而非单独使用，两种模式，只能用其一，而判断的依据，就是是否用了 CheckboxGroup 组件。所以在 Checkbox 组件内，我们用上一节的 "),t("code",[e._v("findComponentUpward")]),e._v(" 方法判断父组件是否有 "),t("code",[e._v("CheckboxGroup")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- checkbox.vue，部分代码省略 --\x3e\n<template>\n  <label>\n    <span>\n      <input\n             v-if="group"\n             type="checkbox"\n             :disabled="disabled"\n             :value="label"\n             v-model="model"\n             @change="change">\n      <input\n             v-else\n             type="checkbox"\n             :disabled="disabled"\n             :checked="currentValue"\n             @change="change">\n    </span>\n    <slot></slot>\n  </label>\n</template>\n<script>\n  import { findComponentUpward } from \'../../utils/assist.js\';\n\n  export default {\n    name: \'iCheckbox\',\n    props: {\n      label: {\n        type: [String, Number, Boolean]\n      }\n    },\n    data () {\n      return {\n        model: [],\n        group: false,\n        parent: null\n      };\n    },\n    mounted () {\n      this.parent = findComponentUpward(this, \'iCheckboxGroup\');\n\n      if (this.parent) {\n        this.group = true;\n      }\n\n      if (this.group) {\n        this.parent.updateModel(true);\n      } else {\n        this.updateModel();\n      }\n    },\n  }\n<\/script>\n\n')])])]),t("p",[e._v("在 mounted 时，通过 findComponentUpward 方法，来判断父级是否有 CheckboxGroup 组件，如果有，就将 "),t("code",[e._v("group")]),e._v(" 置为 true，并触发 CheckboxGroup 的 "),t("code",[e._v("updateModel")]),e._v(" 方法，下文会介绍它的作用。")]),e._v(" "),t("p",[e._v("在 template 里，我们又写了一个 "),t("code",[e._v("<input>")]),e._v(" 来区分是否是 group 模式。Checkbox 的 data 里新增加的 "),t("code",[e._v("model")]),e._v(" 数据，其实就是父级 CheckboxGroup 的 "),t("code",[e._v("value")]),e._v("，会在下文的 "),t("code",[e._v("updateModel")]),e._v(" 方法里给 Checkbox 赋值。")]),e._v(" "),t("p",[e._v("Checkbox 新增的 prop： "),t("code",[e._v("label")]),e._v(" 只会在组合使用时有效，结合 "),t("code",[e._v("model")]),e._v(" 来使用，用法已在 Vue.js 文档中介绍了 "),t("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/forms.html#%E5%A4%8D%E9%80%89%E6%A1%86",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cn.vuejs.org/v2/guide/forms.html#复选框"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("在组合模式下，Checkbox 选中，就不用对 Form 派发事件了，应该在 CheckboxGroup 中派发，所以对 Checkbox 做最后的修改：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\x3c!-- checkbox.vue，部分代码省略 --\x3e\n<script>\n  export default {\n    methods: {\n      change (event) {\n        if (this.disabled) {\n          return false;\n        }\n\n        const checked = event.target.checked;\n        this.currentValue = checked;\n\n        const value = checked ? this.trueValue : this.falseValue;\n        this.$emit('input', value);\n\n        if (this.group) {\n          this.parent.change(this.model);\n        } else {\n          this.$emit('on-change', value);\n          this.dispatch('iFormItem', 'on-form-change', value);\n        }\n      },\n      updateModel () {\n        this.currentValue = this.value === this.trueValue;\n      },\n    },\n  }\n<\/script>\n\n")])])]),t("p",[e._v("剩余的工作，就是完成 checkbox-gourp.vue 文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\x3c!-- checkbox-group.vue --\x3e\n<template>\n  <div>\n    <slot></slot>\n  </div>\n</template>\n<script>\n  import { findComponentsDownward } from '../../utils/assist.js';\n  import Emitter from '../../mixins/emitter.js';\n\n  export default {\n    name: 'iCheckboxGroup',\n    mixins: [ Emitter ],\n    props: {\n      value: {\n        type: Array,\n        default () {\n          return [];\n        }\n      }\n    },\n    data () {\n      return {\n        currentValue: this.value,\n        childrens: []\n      };\n    },\n    methods: {\n      updateModel (update) {\n        this.childrens = findComponentsDownward(this, 'iCheckbox');\n        if (this.childrens) {\n          const { value } = this;\n          this.childrens.forEach(child => {\n            child.model = value;\n\n            if (update) {\n              child.currentValue = value.indexOf(child.label) >= 0;\n              child.group = true;\n            }\n          });\n        }\n      },\n      change (data) {\n        this.currentValue = data;\n        this.$emit('input', data);\n        this.$emit('on-change', data);\n        this.dispatch('iFormItem', 'on-form-change', data);\n      }\n    },\n    mounted () {\n      this.updateModel(true);\n    },\n    watch: {\n      value () {\n        this.updateModel(true);\n      }\n    }\n  };\n<\/script>\n\n\n")])])]),t("p",[e._v("代码很容易理解，需要介绍的就是 "),t("code",[e._v("updateModel")]),e._v(" 方法。可以看到，一共有 3 个地方调用了 "),t("code",[e._v("updateModel")]),e._v("，其中两个是 CheckboxGroup 的 mounted 初始化和 watch 监听的 value 变化时调用；另一个是在 Checkbox 里的 mounted 初始化时调用。这个方法的作用就是在 CheckboxGroup 里通过 "),t("code",[e._v("findComponentsDownward")]),e._v(" 方法找到所有的 Checkbox，然后把 CheckboxGroup 的 "),t("code",[e._v("value")]),e._v("，赋值给 Checkbox 的 "),t("code",[e._v("model")]),e._v("，并根据 Checkbox 的 "),t("code",[e._v("label")]),e._v("，设置一次当前 Checkbox 的选中状态。这样无论是由内而外选择，或由外向内修改数据，都是双向绑定的，而且支持动态增加 Checkbox 的数量。")]),e._v(" "),t("p",[e._v("以上就是组合多选组件——CheckboxGroup & Checkbox 的全部内容，不知道你是否 get 到了呢！")]),e._v(" "),t("p",[e._v("留两个小作业：")]),e._v(" "),t("ol",[t("li",[e._v("将 CheckboxGroup 和 Checkbox 组件集成在 Form 里完成一个数据校验的示例；")]),e._v(" "),t("li",[e._v("参考本节的代码，实现一个单选组件 Radio 和 RadioGroup。")])]),e._v(" "),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),t("p",[e._v("你看到的简单组件，其实都不简单。")]),e._v(" "),t("h2",{attrs:{id:"扩展阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展阅读","aria-hidden":"true"}},[e._v("#")]),e._v(" 扩展阅读")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/598bf7a3f265da3e252a1d6a",target:"_blank",rel:"noopener noreferrer"}},[e._v("v-model 指令在组件中怎么玩"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("注：本节部分代码参考 "),t("a",{attrs:{href:"https://github.com/iview/iview/tree/2.0/src/components/checkbox",target:"_blank",rel:"noopener noreferrer"}},[e._v("iView"),t("OutboundLink")],1),e._v("。")])])}),[],!1,null,null,null);n.default=a.exports}}]);