(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{405:function(e,t,n){"use strict";n.r(t);var a=n(0),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vue-的构造器——extend-与手动挂载——-mount"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-的构造器——extend-与手动挂载——-mount","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 的构造器——extend 与手动挂载——$mount")]),e._v(" "),n("p",[e._v("本节介绍两个 Vue.js 内置但却不常用的 API——extend 和 $mount，它们经常一起使用。不常用，是因为在业务开发中，基本没有它们的用武之地，但在独立组件开发时，在一些特定的场景它们是至关重要的。")]),e._v(" "),n("h2",{attrs:{id:"使用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用场景","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用场景")]),e._v(" "),n("p",[e._v("我们在写 Vue.js 时，不论是用 CDN 的方式还是在 Webpack 里用 npm 引入的 Vue.js，都会有一个根节点，并且创建一个根实例，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<body>\n  <div id=\"app\"></div>\n</body>\n<script>\n  const app = new Vue({\n    el: '#app'\n  });\n<\/script>\n\n")])])]),n("p",[e._v("Webpack 也类似，一般在入口文件 main.js 里，最后会创建一个实例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue';\nimport App from './app.vue';\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n});\n\n")])])]),n("p",[e._v("因为用 Webpack 基本都是前端路由的，它的 html 里一般都只有一个根节点 "),n("code",[e._v('<div id="app"></div>')]),e._v("，其余都是通过 JavaScript 完成，也就是许多的 Vue.js 组件（每个页面也是一个组件）。")]),e._v(" "),n("p",[e._v("有了初始化的实例，之后所有的页面，都由 vue-router 帮我们管理，组件也都是用 "),n("code",[e._v("import")]),e._v(" 导入后局部注册（也有在 main.js 全局注册的），不管哪种方式，组件（或页面）的创建过程我们是无需关心的，只是写好 "),n("code",[e._v(".vue")]),e._v(" 文件并导入即可。这样的组件使用方式，有几个特点：")]),e._v(" "),n("ol",[n("li",[e._v("所有的内容，都是在 "),n("code",[e._v("#app")]),e._v(" 节点内渲染的；")]),e._v(" "),n("li",[e._v("组件的模板，是事先定义好的；")]),e._v(" "),n("li",[e._v("由于组件的特性，注册的组件只能在当前位置渲染。")])]),e._v(" "),n("p",[e._v("比如你要使用一个组件 "),n("code",[e._v("<i-date-picker>")]),e._v("，渲染时，这个自定义标签就会被替换为组件的内容，而且在哪写的自定义标签，就在哪里被替换。换句话说，常规的组件使用方式，只能在规定的地方渲染组件，这在一些特殊场景下就比较局限了，例如：")]),e._v(" "),n("ol",[n("li",[e._v("组件的模板是通过调用接口从服务端获取的，需要动态渲染组件；")]),e._v(" "),n("li",[e._v("实现类似原生 "),n("code",[e._v("window.alert()")]),e._v(" 的提示框组件，它的位置是在 "),n("code",[e._v("<body>")]),e._v(" 下，而非 "),n("code",[e._v('<div id="app">')]),e._v("，并且不会通过常规的组件自定义标签的形式使用，而是像 JS 调用函数一样使用。")])]),e._v(" "),n("p",[e._v("一般来说，在我们访问页面时，组件就已经渲染就位了，对于场景 1，组件的渲染是异步的，甚至预先不知道模板是什么。对于场景 2，其实并不陌生，在 jQuery 时代，通过操作 DOM，很容易就能实现，你可以沿用这种思路，只是这种做法不那么 Vue，既然使用 Vue.js 了，就应该用 Vue 的思路来解决问题。对于这两种场景，Vue.extend 和 vm.$mount 语法就派上用场了。")]),e._v(" "),n("h2",{attrs:{id:"用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用法","aria-hidden":"true"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),n("p",[e._v("上文我们说到，创建一个 Vue 实例时，都会有一个选项 "),n("code",[e._v("el")]),e._v("，来指定实例的根节点，如果不写 "),n("code",[e._v("el")]),e._v(" 选项，那组件就处于未挂载状态。"),n("code",[e._v("Vue.extend")]),e._v(" 的作用，就是基于 Vue 构造器，创建一个“子类”，它的参数跟 "),n("code",[e._v("new Vue")]),e._v(" 的基本一样，但 "),n("code",[e._v("data")]),e._v(" 要跟组件一样，是个函数，再配合 "),n("code",[e._v("$mount")]),e._v(" ，就可以让组件渲染，并且挂载到任意指定的节点上，比如 body。")]),e._v(" "),n("p",[e._v("比如上文的场景，就可以这样写：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue';\n\nconst AlertComponent = Vue.extend({\n  template: '<div>{{ message }}</div>',\n  data () {\n    return {\n      message: 'Hello, Aresn'\n    };\n  },\n});\n\n")])])]),n("p",[e._v("这一步，我们创建了一个构造器，这个过程就可以解决异步获取 template 模板的问题，下面要手动渲染组件，并把它挂载到 body 下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const component = new AlertComponent().$mount();\n\n")])])]),n("p",[e._v("这一步，我们调用了 "),n("code",[e._v("$mount")]),e._v(" 方法对组件进行了手动渲染，但它仅仅是被渲染好了，并没有挂载到节点上，也就显示不了组件。此时的 "),n("code",[e._v("component")]),e._v(" 已经是一个标准的 Vue 组件实例，因此它的 "),n("code",[e._v("$el")]),e._v(" 属性也可以被访问：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("document.body.appendChild(component.$el);\n\n")])])]),n("p",[e._v("当然，除了 body，你还可以挂载到其它节点上。")]),e._v(" "),n("p",[n("code",[e._v("$mount")]),e._v(" 也有一些快捷的挂载方式，以下两种都是可以的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 在 $mount 里写参数来指定挂载的节点\nnew AlertComponent().$mount('#app');\n// 不用 $mount，直接在创建实例时指定 el 选项\nnew AlertComponent({ el: '#app' });\n\n")])])]),n("p",[e._v("实现同样的效果，除了用 extend 外，也可以直接创建 Vue 实例，并且用一个 Render 函数来渲染一个 .vue 文件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue';\nimport Notification from './notification.vue';\n\nconst props = {};  // 这里可以传入一些组件的 props 选项\n\nconst Instance = new Vue({\n  render (h) {\n    return h(Notification, {\n      props: props\n    });\n  }\n});\n\nconst component = Instance.$mount();\ndocument.body.appendChild(component.$el);\n\n")])])]),n("p",[e._v("这样既可以使用 .vue 来写复杂的组件（毕竟在 template 里堆字符串很痛苦），还可以根据需要传入适当的 props。渲染后，如果想操作 Render 的 "),n("code",[e._v("Notification")]),e._v(" 实例，也是很简单的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const notification = Instance.$children[0];\n\n")])])]),n("p",[e._v("因为 Instance 下只 Render 了 Notification 一个子组件，所以可以用 "),n("code",[e._v("$children[0]")]),e._v(" 访问到。")]),e._v(" "),n("blockquote",[n("p",[e._v("如果你还不理解这样做的目的，没有关系，后面小节的两个实战你会感受到它的用武之地。")])]),e._v(" "),n("p",[e._v("需要注意的是，我们是用 "),n("code",[e._v("$mount")]),e._v(" 手动渲染的组件，如果要销毁，也要用 "),n("code",[e._v("$destroy")]),e._v(" 来手动销毁实例，必要时，也可以用 "),n("code",[e._v("removeChild")]),e._v(" 把节点从 DOM 中移除。")]),e._v(" "),n("h2",{attrs:{id:"结语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),n("p",[e._v("这两个 API 并不难理解，只是不常使用罢了，因为多数情况下，我们只关注在业务层，并使用现成的组件库。")]),e._v(" "),n("p",[e._v("使用 Vue.js 也有二八原则，即 80% 的人看过 "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js 文档教程篇"),n("OutboundLink")],1),e._v("，20% 的人看过 "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js 文档 API"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("下一节，我们来做点有趣的东西。")]),e._v(" "),n("h2",{attrs:{id:"扩展阅读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展阅读","aria-hidden":"true"}},[e._v("#")]),e._v(" 扩展阅读")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://juejin.im/post/59da1c116fb9a00a4a4cf6dd",target:"_blank",rel:"noopener noreferrer"}},[e._v("聊聊 Vue.js 的 template 编译"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);